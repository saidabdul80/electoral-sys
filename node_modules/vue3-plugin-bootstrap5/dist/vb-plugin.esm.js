var VbAlert = {
    createIsHandler(Alert, el, binding) {
        //console.log('alert createIsHandler', el, binding)
        let closeEventHandler = () => {
            let evt = document.createEvent('HTMLEvents');
            evt.initEvent('vb-close-bs-alert', true, true);
            el.dispatchEvent(evt);
        };
        let closedEventHandler = () => {
            let evt = document.createEvent('HTMLEvents');
            evt.initEvent('vb-closed-bs-alert', true, true);
            el.dispatchEvent(evt);
        };

        return {
            created() {
                if (!el.$vb) el.$vb = {};
            },
            beforeMount() {
                let ins = Alert.getInstance(el);
                if (!ins) ins = new Alert(el, binding.value);
                el.$vb.alert = ins;
                el.addEventListener('close.bs.alert', closeEventHandler);
                el.addEventListener('closed.bs.alert', closedEventHandler);
            },
            beforeUnmount() {
                let ins = Alert.getInstance(el);
                if (ins) ins.dispose();
                el.$vb.alert = undefined;
                el.removeEventListener('close.bs.alert', closeEventHandler);
                el.removeEventListener('closed.bs.alert', closedEventHandler);
            }
        }
    },


};

var VbCarousel = {

    createIsHandler(Carousel, el, binding) {
        //console.log('carousel createIsHandler')
        let slideEventHandler = () => {
            let evt = document.createEvent('HTMLEvents');
            evt.initEvent('vb-slide-bs-carousel', true, true);
            el.dispatchEvent(evt);
        };
        let slidEventHandler = () => {
            let evt = document.createEvent('HTMLEvents');
            evt.initEvent('vb-slid-bs-carousel', true, true);
            el.dispatchEvent(evt);
        };

        return {
            created() {
                if (!el.$vb) el.$vb = {};
            },
            beforeMount() {
                //console.log('carousel beforeMount', el)
                let ins = Carousel.getInstance(el);
                if (!ins) ins = new Carousel(el, binding.value);
                el.$vb.carousel = ins;
                el.addEventListener('slide.bs.carousel', slideEventHandler);
                el.addEventListener('slid.bs.carousel', slidEventHandler);
            },
            beforeUnmount() {
                let ins = Carousel.getInstance(el);
                if (ins) ins.dispose();
                el.$vb.carousel = undefined;
                el.removeEventListener('slide.bs.carousel', slideEventHandler);
                el.removeEventListener('slid.bs.carousel', slidEventHandler);
            }
        }
    },


};

var VbCollapse = {

    createIsHandler(Collapse, el, binding) {
        //console.log('collapse createIsHandler')
        let showEventHandler = () => {
            let evt = document.createEvent('HTMLEvents');
            evt.initEvent('vb-show-bs-collapse', true, true);
            el.dispatchEvent(evt);
        };
        let shownEventHandler = () => {
            let evt = document.createEvent('HTMLEvents');
            evt.initEvent('vb-shown-bs-collapse', true, true);
            el.dispatchEvent(evt);
        };
        let hideEventHandler = () => {
            let evt = document.createEvent('HTMLEvents');
            evt.initEvent('vb-hide-bs-collapse', true, true);
            el.dispatchEvent(evt);
        };
        let hiddenEventHandler = () => {
            let evt = document.createEvent('HTMLEvents');
            evt.initEvent('vb-hidden-bs-collapse', true, true);
            el.dispatchEvent(evt);
        };

        return {
            created() {
                if (!el.$vb) el.$vb = {};
            },
            beforeMount() {
                //console.log('collapse beforeMount', el)
                let ins = Collapse.getInstance(el);
                if (!ins) ins = new Collapse(el, binding.value);
                el.$vb.collapse = ins;
                el.addEventListener('show.bs.collapse', showEventHandler);
                el.addEventListener('shown.bs.collapse', shownEventHandler);
                el.addEventListener('hide.bs.collapse', hideEventHandler);
                el.addEventListener('hidden.bs.collapse', hiddenEventHandler);
            },
            beforeUnmount() {
                let ins = Collapse.getInstance(el);
                if (ins) ins.dispose();
                el.$vb.collapse = undefined;
                el.removeEventListener('show.bs.collapse', showEventHandler);
                el.removeEventListener('shown.bs.collapse', shownEventHandler);
                el.removeEventListener('hide.bs.collapse', hideEventHandler);
                el.removeEventListener('hidden.bs.collapse', hiddenEventHandler);
            },
        }
    },



};

var VbDropdown = {

    createIsHandler(Dropdown, el, binding) {
        //console.log('dropdown createIsHandler')
        let showEventHandler = () => {
            let evt = document.createEvent('HTMLEvents');
            evt.initEvent('vb-show-bs-dropdown', true, true);
            el.dispatchEvent(evt);
        };
        let shownEventHandler = () => {
            let evt = document.createEvent('HTMLEvents');
            evt.initEvent('vb-shown-bs-dropdown', true, true);
            el.dispatchEvent(evt);
        };
        let hideEventHandler = () => {
            let evt = document.createEvent('HTMLEvents');
            evt.initEvent('vb-hide-bs-dropdown', true, true);
            el.dispatchEvent(evt);
        };
        let hiddenEventHandler = () => {
            let evt = document.createEvent('HTMLEvents');
            evt.initEvent('vb-hidden-bs-dropdown', true, true);
            el.dispatchEvent(evt);
        };

        return {
            created() {
                if (!el.$vb) el.$vb = {};
            },
            mounted() {  // bs requires we are in the dom before creation
                //console.log('dropdown beforeMount', el)
                let ins = Dropdown.getInstance(el);
                if (!ins) ins = new Dropdown(el, binding.value);
                el.$vb.dropdown = ins;
                el.addEventListener('show.bs.dropdown', showEventHandler);
                el.addEventListener('shown.bs.dropdown', shownEventHandler);
                el.addEventListener('hide.bs.dropdown', hideEventHandler);
                el.addEventListener('hidden.bs.dropdown', hiddenEventHandler);
            },
            updated() {
                let ins = Dropdown.getInstance(el);
                if (ins) ins.update();
            },
            beforeUnmount() {
                let ins = Dropdown.getInstance(el);
                if (ins) ins.dispose();
                el.$vb.dropdown = undefined;
                el.removeEventListener('show.bs.dropdown', showEventHandler);
                el.removeEventListener('shown.bs.dropdown', shownEventHandler);
                el.removeEventListener('hide.bs.dropdown', hideEventHandler);
                el.removeEventListener('hidden.bs.dropdown', hiddenEventHandler);
            }
        }
    },



};

var VbModal = {

    createIsHandler(Modal, el, binding, baseOptions) {
        //console.log('modal createIsHandler', Modal)

        // bootstrap by default doesn't allow layering of modals, fix this by hiding the first when a second is shown
        // then when the second is hidden, show the first again (hide these show/hide events from listeners)
        const layeredBackdropFix = () => {
            let zIndex = baseOptions.vbModalBaseZindex;
            if (zIndex) {
                el.style.zIndex = String(zIndex);
                setTimeout(function () {
                    // ensure the backdrop is one back in the zindex
                    let bdEl = document.querySelector('.modal-backdrop');
                    if (bdEl) {
                        bdEl.style.zIndex = String(zIndex - 20);
                    }
                }, 0);
            }
        };

        let moveShownModalBehind = () => {
            let modalsVisible = document.querySelectorAll('.modal.show');
            modalsVisible.forEach((visibleModalEl) => {  // should only be one
                if (visibleModalEl && visibleModalEl.$vb && visibleModalEl.$vb.modal) {
                    visibleModalEl.$vb.modalIsBehind = true;
                    let modalBehind = {wasAnimated: false, backdropWasAnimated: false, el: visibleModalEl};
                    if (visibleModalEl.classList.contains('fade')) {
                        modalBehind.wasAnimated = true;
                        visibleModalEl.classList.remove('fade');
                    }
                    if (visibleModalEl.$vb.modal._backdrop._config.isAnimated) {
                        modalBehind.backdropWasAnimated = true;
                        visibleModalEl.$vb.modal._backdrop._config.isAnimated = false;
                    }
                    visibleModalEl.$vb.modal.hide();
                    el.$vb.modalBehind = modalBehind;
                }
            });
        };
        let showModalBehind = () => {
            //console.log(el.$vb)
            if (el.$vb.modalBehind) {
                let modalBehind = el.$vb.modalBehind;
                modalBehind.el.$vb.modal.show();
                if (modalBehind.wasAnimated) modalBehind.el.classList.add('fade');
                if (modalBehind.backdropWasAnimated) modalBehind.el.$vb.modal._backdrop._config.isAnimated = true;
                el.$vb.modalBehind = null;
            }
        };

        let showEventHandler = () => {
            if (el.$vb.modalIsBehind) return;
            moveShownModalBehind();
            let evt = document.createEvent('HTMLEvents');
            evt.initEvent('vb-show-bs-modal', true, true);
            el.dispatchEvent(evt);
            layeredBackdropFix();
        };
        let shownEventHandler = () => {
            if (el.$vb.modalIsBehind) {
                el.$vb.modalIsBehind = false;
                return;
            }
            let evt = document.createEvent('HTMLEvents');
            evt.initEvent('vb-shown-bs-modal', true, true);
            el.dispatchEvent(evt);
        };
        let hideEventHandler = (e) => {
            if (el.$vb.modalIsBehind) return;
            let evt = document.createEvent('HTMLEvents');
            evt.initEvent('vb-hide-bs-modal', true, true);
            el.dispatchEvent(evt);
            if (evt.defaultPrevented) e.preventDefault();
        };
        let hiddenEventHandler = () => {
            if (el.$vb.modalIsBehind) return;
            let evt = document.createEvent('HTMLEvents');
            evt.initEvent('vb-hidden-bs-modal', true, true);
            el.dispatchEvent(evt);
            showModalBehind();
        };

        return {
            created() {
                if (!el.$vb) el.$vb = {modalIsBehind: false, modalBehind: null};
            },
            beforeMount() {
                //console.log('modal beforeMount', el)
                let ins = Modal.getInstance(el);
                if (!ins) ins = new Modal(el, binding.value);
                el.$vb.modal = ins;
                el.addEventListener('show.bs.modal', showEventHandler);
                el.addEventListener('shown.bs.modal', shownEventHandler);
                el.addEventListener('hide.bs.modal', hideEventHandler);
                el.addEventListener('hidden.bs.modal', hiddenEventHandler);
            },
            mounted() {
                //console.log('modal mounted', el)
                let modifiers = Object.keys(binding.modifiers).map(key => key);
                if (modifiers && modifiers.length > 0 && modifiers[0] === 'show') {
                    let ins = Modal.getInstance(el);
                    if (ins) ins.show();
                }
            },
            updated() {
                //console.log('modal updated')
                let ins = Modal.getInstance(el);
                if (ins) ins.handleUpdate();
            },
            beforeUnmount() {
                //console.log('modal beforeUnmount', el)

                // ensure that any hide.bs.modal events are already removed and can't call preventDefault
                el.removeEventListener('show.bs.modal', showEventHandler);
                el.removeEventListener('shown.bs.modal', shownEventHandler);
                el.removeEventListener('hide.bs.modal', hideEventHandler);
                el.removeEventListener('hidden.bs.modal', hiddenEventHandler);

                let ins = Modal.getInstance(el);

                // if modal is shown or transitioning we need to remove NOW in this JS loop to prevent the backdrop
                // being orphaned.  We ideally would not call private functions however there is no public method to
                // support immediate hiding
                if (ins && (ins._isShown||ins._isTransitioning)) {
                    if (el.classList.contains('fade')) el.classList.remove('fade');  // remove animation
                    ins._backdrop._config.isAnimated = false;  // remove backdrop animation
                    ins._hideModal();  // this should immediately hide the modal with no animation
                }
                if (ins) ins.dispose();
                el.$vb.modal = undefined;
                //console.log('modal cleanup done', el)
            },
            unmounted() {
                //
            }
        }
    },


};

var VbOffcanvas = {

    createIsHandler(Offcanvas, el, binding) {
        //console.log('offcanvas createIsHandler')

        let showEventHandler = () => {
            let evt = document.createEvent('HTMLEvents');
            evt.initEvent('vb-show-bs-offcanvas', true, true);
            el.dispatchEvent(evt);
        };
        let shownEventHandler = () => {
            let evt = document.createEvent('HTMLEvents');
            evt.initEvent('vb-shown-bs-offcanvas', true, true);
            el.dispatchEvent(evt);
        };
        let hideEventHandler = (e) => {
            let evt = document.createEvent('HTMLEvents');
            evt.initEvent('vb-hide-bs-offcanvas', true, true);
            el.dispatchEvent(evt);
            if (evt.defaultPrevented) e.preventDefault();
        };
        let hiddenEventHandler = () => {
            let evt = document.createEvent('HTMLEvents');
            evt.initEvent('vb-hidden-bs-offcanvas', true, true);
            el.dispatchEvent(evt);
        };

        return {
            created() {
                if (!el.$vb) el.$vb = {};
            },
            beforeMount() {
                //console.log('offcanvas beforeMount', el)
                let ins = Offcanvas.getInstance(el);
                if (!ins) ins = new Offcanvas(el, binding.value);
                el.$vb.offcanvas = ins;
                el.addEventListener('show.bs.offcanvas', showEventHandler);
                el.addEventListener('shown.bs.offcanvas', shownEventHandler);
                el.addEventListener('hide.bs.offcanvas', hideEventHandler);
                el.addEventListener('hidden.bs.offcanvas', hiddenEventHandler);
            },
            beforeUnmount() {
                //console.log('offcanvas beforeUnmount', el)
                // run in next loop to ensure that any hide.bs.modal events are already removed and can't call preventDefault
                setTimeout(() => {
                    let ins = Offcanvas.getInstance(el);
                    // we ideally would not call _isShown (private) however we need it closed with no transition
                    if (ins && ins._isShown) {
                        // Vue removes the element in the next loop, so we need to ensure that the animation doesn't
                        // run and Bootstrap can cleanup immediately
                        if (el.classList && el.classList.contains('fade')) el.classList.remove('fade');
                        ins.hide();
                    }
                    if (ins) ins.dispose();
                    el.$vb.offcanvas = undefined;
                    el.removeEventListener('show.bs.offcanvas', showEventHandler);
                    el.removeEventListener('shown.bs.offcanvas', shownEventHandler);
                    el.removeEventListener('hide.bs.offcanvas', hideEventHandler);
                    el.removeEventListener('hidden.bs.offcanvas', hiddenEventHandler);
                    //console.log('modal cleanup done', el)
                });
            }
        }
    },



};

var VbPopover = {

    createIsHandler(Popover, el, binding) {
        //console.log('popover createIsHandler')

        let showEventHandler = () => {
            let evt = document.createEvent('HTMLEvents');
            evt.initEvent('vb-show-bs-popover', true, true);
            el.dispatchEvent(evt);
        };
        let shownEventHandler = () => {
            let evt = document.createEvent('HTMLEvents');
            evt.initEvent('vb-shown-bs-popover', true, true);
            el.dispatchEvent(evt);
        };
        let hideEventHandler = () => {
            let evt = document.createEvent('HTMLEvents');
            evt.initEvent('vb-hide-bs-popover', true, true);
            el.dispatchEvent(evt);
        };
        let hiddenEventHandler = () => {
            let evt = document.createEvent('HTMLEvents');
            evt.initEvent('vb-hidden-bs-popover', true, true);
            el.dispatchEvent(evt);
        };
        let insertedEventHandler = () => {
            let evt = document.createEvent('HTMLEvents');
            evt.initEvent('vb-inserted-bs-popover', true, true);
            el.dispatchEvent(evt);
        };

        return {
            created() {
                if (!el.$vb) el.$vb = {};
            },
            beforeMount() {
                //console.log('popover beforeMount', el)
                let ins = Popover.getInstance(el);
                if (!ins) ins = new Popover(el, binding.value);
                el.$vb.popover = ins;
                el.addEventListener('show.bs.popover', showEventHandler);
                el.addEventListener('shown.bs.popover', shownEventHandler);
                el.addEventListener('hide.bs.popover', hideEventHandler);
                el.addEventListener('hidden.bs.popover', hiddenEventHandler);
                el.addEventListener('inserted.bs.popover', insertedEventHandler);
            },
            updated() {
                let ins = Popover.getInstance(el);
                if (ins) ins.update();
            },
            beforeUnmount() {
                let ins = Popover.getInstance(el);
                if (ins) ins.dispose();
                el.$vb.popover = undefined;
                el.removeEventListener('show.bs.popover', showEventHandler);
                el.removeEventListener('shown.bs.popover', shownEventHandler);
                el.removeEventListener('hide.bs.popover', hideEventHandler);
                el.removeEventListener('hidden.bs.popover', hiddenEventHandler);
                el.removeEventListener('inserted.bs.popover', insertedEventHandler);
            }
        }
    },

};

var VbScrollSpy = {

    createIsHandler(ScrollSpy, el, binding) {
        //console.log('scrollspy createIsHandler')

        let activateEventHandler = () => {
            let evt = document.createEvent('HTMLEvents');
            evt.initEvent('vb-activate-bs-scrollspy', true, true);
            el.dispatchEvent(evt);
        };
        return {
            created() {
                if (!el.$vb) el.$vb = {};
            },
            beforeMount() {
                //console.log('scrollspy beforeMount', el)
                let ins = ScrollSpy.getInstance(el);
                if (!ins) ins = new ScrollSpy(el, binding.value);
                el.$vb.scrollspy = ins;

                el.addEventListener('activate.bs.scrollspy', activateEventHandler);
            },
            updated() {
                let ins = ScrollSpy.getInstance(el);
                if (ins) ins.refresh();
            },
            beforeUnmount() {
                let ins = ScrollSpy.getInstance(el);
                if (ins) ins.dispose();
                el.$vb.scrollspy = undefined;
                el.removeEventListener('activate.bs.scrollspy', activateEventHandler);
            }
        }
    },



};

var VbTab = {
    createIsHandler(Tab, el, binding) {
        //console.log('tab createIsHandler', el, binding)

        let showEventHandler = () => {
            let evt = document.createEvent('HTMLEvents');
            evt.initEvent('vb-show-bs-tab', true, true);
            el.dispatchEvent(evt);
        };
        let shownEventHandler = () => {
            let evt = document.createEvent('HTMLEvents');
            evt.initEvent('vb-shown-bs-tab', true, true);
            el.dispatchEvent(evt);
        };
        let hideEventHandler = () => {
            let evt = document.createEvent('HTMLEvents');
            evt.initEvent('vb-hide-bs-tab', true, true);
            el.dispatchEvent(evt);
        };
        let hiddenEventHandler = () => {
            let evt = document.createEvent('HTMLEvents');
            evt.initEvent('vb-hidden-bs-tab', true, true);
            el.dispatchEvent(evt);
        };

        return {
            created() {
                if (!el.$vb) el.$vb = {};
            },
            mounted() {
                let ins = Tab.getInstance(el);
                if (!ins) ins = new Tab(el, binding.value);
                el.$vb.tab = ins;
                el.addEventListener('show.bs.tab', showEventHandler);
                el.addEventListener('shown.bs.tab', shownEventHandler);
                el.addEventListener('hide.bs.tab', hideEventHandler);
                el.addEventListener('hidden.bs.tab', hiddenEventHandler);
            },
            beforeUnmount() {
                let ins = Tab.getInstance(el);
                if (ins) ins.dispose();
                el.removeEventListener('show.bs.tab', showEventHandler);
                el.removeEventListener('shown.bs.tab', shownEventHandler);
                el.removeEventListener('hide.bs.tab', hideEventHandler);
                el.removeEventListener('hidden.bs.tab', hiddenEventHandler);
            }
        }
    },

};

var VbToast = {

    createIsHandler(Toast, el, binding) {
        //console.log('toast createIsHandler')

        let showEventHandler = () => {
            let evt = document.createEvent('HTMLEvents');
            evt.initEvent('vb-show-bs-toast', true, true);
            el.dispatchEvent(evt);
        };
        let shownEventHandler = () => {
            let evt = document.createEvent('HTMLEvents');
            evt.initEvent('vb-shown-bs-toast', true, true);
            el.dispatchEvent(evt);
        };
        let hideEventHandler = () => {
            let evt = document.createEvent('HTMLEvents');
            evt.initEvent('vb-hide-bs-toast', true, true);
            el.dispatchEvent(evt);
        };
        let hiddenEventHandler = () => {
            let evt = document.createEvent('HTMLEvents');
            evt.initEvent('vb-hidden-bs-toast', true, true);
            el.dispatchEvent(evt);
        };

        return {
            created() {
                if (!el.$vb) el.$vb = {};
            },
            beforeMount() {
                //console.log('toast beforeMount', el)
                let ins = Toast.getInstance(el);
                if (!ins) ins = new Toast(el, binding.value);
                el.$vb.toast = ins;

                el.addEventListener('show.bs.toast', showEventHandler);
                el.addEventListener('shown.bs.toast', shownEventHandler);
                el.addEventListener('hide.bs.toast', hideEventHandler);
                el.addEventListener('hidden.bs.toast', hiddenEventHandler);
            },
            updated() {
                let ins = Toast.getInstance(el);
                if (ins) ins.refresh();
            },
            beforeUnmount() {
                let ins = Toast.getInstance(el);
                if (ins) ins.dispose();
                el.$vb.toast = undefined;
                el.removeEventListener('show.bs.toast', showEventHandler);
                el.removeEventListener('shown.bs.toast', shownEventHandler);
                el.removeEventListener('hide.bs.toast', hideEventHandler);
                el.removeEventListener('hidden.bs.toast', hiddenEventHandler);
            }
        }
    },


};

var VbTooltip = {

    createIsHandler(Tooltip, el, binding) {
        //console.log('tooltip createIsHandler')

        let showEventHandler = () => {
            let evt = document.createEvent('HTMLEvents');
            evt.initEvent('vb-show-bs-tooltip', true, true);
            el.dispatchEvent(evt);
        };
        let shownEventHandler = () => {
            let evt = document.createEvent('HTMLEvents');
            evt.initEvent('vb-shown-bs-tooltip', true, true);
            el.dispatchEvent(evt);
        };
        let hideEventHandler = () => {
            let evt = document.createEvent('HTMLEvents');
            evt.initEvent('vb-hide-bs-tooltip', true, true);
            el.dispatchEvent(evt);
        };
        let hiddenEventHandler = () => {
            let evt = document.createEvent('HTMLEvents');
            evt.initEvent('vb-hidden-bs-tooltip', true, true);
            el.dispatchEvent(evt);
        };
        let insertedEventHandler = () => {
            let evt = document.createEvent('HTMLEvents');
            evt.initEvent('vb-inserted-bs-tooltip', true, true);
            el.dispatchEvent(evt);
        };

        return {
            created() {
                if (!el.$vb) el.$vb = {};
            },
            beforeMount() {
                //console.log('scrollspy beforeMount', el)
                let ins = Tooltip.getInstance(el);
                if (!ins) ins = new Tooltip(el, binding.value);
                el.$vb.scrollspy = ins;

                el.addEventListener('show.bs.tooltip', showEventHandler);
                el.addEventListener('shown.bs.tooltip', shownEventHandler);
                el.addEventListener('hide.bs.tooltip', hideEventHandler);
                el.addEventListener('hidden.bs.tooltip', hiddenEventHandler);
                el.addEventListener('inserted.bs.tooltip', insertedEventHandler);
            },
            updated() {
                let ins = Tooltip.getInstance(el);
                if (ins) ins.update();
            },
            beforeUnmount() {
                let ins = Tooltip.getInstance(el);
                if (ins) ins.dispose();
                el.$vb.tooltip = undefined;
                el.removeEventListener('show.bs.tooltip', showEventHandler);
                el.removeEventListener('shown.bs.tooltip', shownEventHandler);
                el.removeEventListener('hide.bs.tooltip', hideEventHandler);
                el.removeEventListener('hidden.bs.tooltip', hiddenEventHandler);
                el.removeEventListener('inserted.bs.tooltip', insertedEventHandler);
            }
        }
    },
    
};

function createVbPlugin(bootstrapObjects, options) {
    return {

        /**
         * Initialize vue plugins
         *
         * @param {Object} app
         */
        install(app) {
            //console.log('createVbPlugins install', app)
            if (!bootstrapObjects) bootstrapObjects = {};
            let baseOptions = Object.assign({
                vbModalBaseZindex: null  // default null means that5 we won't alter zindex
            }, options);

            let handlerConfs = {
                alert: { bsObject: bootstrapObjects.Alert, handlerObject: VbAlert },
                carousel: { bsObject: bootstrapObjects.Carousel, handlerObject: VbCarousel },
                collapse: { bsObject: bootstrapObjects.Collapse, handlerObject: VbCollapse },
                dropdown: { bsObject: bootstrapObjects.Dropdown, handlerObject: VbDropdown },
                modal: { bsObject: bootstrapObjects.Modal, handlerObject: VbModal },
                offcanvas: { bsObject: bootstrapObjects.Offcanvas, handlerObject: VbOffcanvas },
                popover: { bsObject: bootstrapObjects.Popover, handlerObject: VbPopover },
                scrollspy: { bsObject: bootstrapObjects.ScrollSpy, handlerObject: VbScrollSpy },
                tab: { bsObject: bootstrapObjects.Tab, handlerObject: VbTab },
                pill: { bsObject: bootstrapObjects.Tab, handlerObject: VbTab }, // special case for tab
                list: { bsObject: bootstrapObjects.Tab, handlerObject: VbTab }, // special case for tab
                toast: { bsObject: bootstrapObjects.Toast, handlerObject: VbToast },
                tooltip: { bsObject: bootstrapObjects.Tooltip, handlerObject: VbTooltip }
            };

            let handlerObjs = [];
            let getHandler = function(directiveType, el, binding, removeHandler) {
                //console.log('getHandler', directiveType)
                let handlerIdx = handlerObjs.findIndex(handler => {
                    return handler.directiveType === directiveType && handler.el === el && handler.arg === binding.arg
                });
                //console.log('handlerIdx', handlerIdx)
                if (handlerIdx !== -1) {
                    let handler = handlerObjs[handlerIdx];
                    if (removeHandler) handlerObjs.splice(handlerIdx, 1);
                    return handler
                }
                return null
            };
            let addHandler = function(directiveType, el, binding, handlerIns) {
                handlerObjs.push({
                    directiveType: directiveType, el: el, arg: binding.arg,
                    handlerIns: handlerIns
                });
            };

            app.directive('vb-is', {
                created(el, binding) {
                    //console.log('is created', binding.arg, components)
                    let handlerConf = handlerConfs[binding.arg];
                    if (handlerConf && handlerConf.bsObject && handlerConf.handlerObject &&
                        handlerConf.handlerObject.createIsHandler) {
                        let handlerIns = handlerConf.handlerObject.createIsHandler(handlerConf.bsObject, el, binding, baseOptions);
                        addHandler('is', el, binding, handlerIns);
                        //console.log('handlerIns', handlerIns);
                        if (handlerIns) handlerIns.created();
                    }
                },
                beforeMount(el, binding) {
                    let handler = getHandler('is', el, binding, false);
                    if (handler && handler.handlerIns.beforeMount) handler.handlerIns.beforeMount();
                },
                mounted(el, binding) {
                    let handler = getHandler('is', el, binding, false);
                    if (handler && handler.handlerIns.mounted) handler.handlerIns.mounted();
                },
                updated(el, binding) {
                    let handler = getHandler('is', el, binding, false);
                    if (handler && handler.handlerIns.updated) handler.handlerIns.updated();
                },
                beforeUnmount(el, binding) {
                    let handler = getHandler('is', el, binding, false);
                    if (handler && handler.handlerIns.beforeUnmount) handler.handlerIns.beforeUnmount();
                },
                unmounted(el, binding) {
                    let handler = getHandler('is', el, binding, true);
                    if (handler && handler.handlerIns.unmounted) handler.handlerIns.unmounted();
                },
            });

        }
    }
}

export { createVbPlugin };
